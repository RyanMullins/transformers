# coding=utf-8
# Copyright 2025 Google Inc. HuggingFace Inc. team. All rights reserved.
#
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from dataclasses import dataclass

import torch
import torch.utils.checkpoint

from ...modeling_outputs import ModelOutput
from ...modeling_utils import PreTrainedModel
from ...utils import (
    add_start_docstrings_to_model_forward,
    logging,
    replace_return_docstrings,
)
from ...utils.deprecation import deprecate_kwarg
from ..auto import AutoModelForCausalLM, AutoModelForImageTextToText
from .configuration_shieldgemma import ShieldGemmaConfig


_CHECKPOINT_FOR_DOC = "google/shieldgemma-2-4b-it"
_CONFIG_FOR_DOC = "ShieldGemmaConfig"

_DEFAULT_YES_TOKEN_INDEX = 10_784
_DEFAULT_NO_TOKEN_INDEX = 3771

logger = logging.get_logger(__name__)

SHIELDGEMMA_INPUTS_DOCSTRING = r"""
    Args:
        input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):
            Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide
            it.

            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and
            [`PreTrainedTokenizer.__call__`] for details.

            [What are input IDs?](../glossary#input-ids)
        attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):
            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:

            - 1 for tokens that are **not masked**,
            - 0 for tokens that are **masked**.

            [What are attention masks?](../glossary#attention-mask)

            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and
            [`PreTrainedTokenizer.__call__`] for details.

            If `past_key_values` is used, optionally only the last `input_ids` have to be input (see
            `past_key_values`).

            If you want to change padding behavior, you should read [`modeling_opt._prepare_decoder_attention_mask`]
            and modify to your needs. See diagram 1 in [the paper](https://arxiv.org/abs/1910.13461) for more
            information on the default strategy.

            - 1 indicates the head is **not masked**,
            - 0 indicates the head is **masked**.
        position_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):
            Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0,
            config.n_positions - 1]`.

            [What are position IDs?](../glossary#position-ids)
        past_key_values (`Cache` or `tuple(tuple(torch.FloatTensor))`, *optional*):
            Pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention
            blocks) that can be used to speed up sequential decoding. This typically consists in the `past_key_values`
            returned by the model at a previous stage of decoding, when `use_cache=True` or `config.use_cache=True`.

            Two formats are allowed:
            - a [`~cache_utils.Cache`] instance, see our
            [kv cache guide](https://huggingface.co/docs/transformers/en/kv_cache);
            - Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of
            shape `(batch_size, num_heads, sequence_length, embed_size_per_head)`). This is also known as the legacy
            cache format.

            The model will output the same cache format that is fed as input. If no `past_key_values` are passed, the
            legacy cache format will be returned.

            If `past_key_values` are used, the user can optionally input only the last `input_ids` (those that don't
            have their past key value states given to this model) of shape `(batch_size, 1)` instead of all `input_ids`
            of shape `(batch_size, sequence_length)`.
        inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):
            Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This
            is useful if you want more control over how to convert `input_ids` indices into associated vectors than the
            model's internal embedding lookup matrix.
        use_cache (`bool`, *optional*):
            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see
            `past_key_values`).
        output_attentions (`bool`, *optional*):
            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned
            tensors for more detail.
        output_hidden_states (`bool`, *optional*):
            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for
            more detail.
        return_dict (`bool`, *optional*):
            Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.
        cache_position (`torch.LongTensor` of shape `(sequence_length)`, *optional*):
            Indices depicting the position of the input sequence tokens in the sequence. Contrarily to `position_ids`,
            this tensor is not affected by padding. It is used to update the cache in the correct position and to infer
            the complete sequence length.
"""


@dataclass
class ShieldGemmaClassifierOutput(ModelOutput):
    """ShieldGemma2 classifies imags as violative or not relative to a specific policy
    Args:
    """
    logits: torch.Tensor
    probabilities: torch.Tensor


class ShieldGemmaLogitsProcessor():
    """Filters the provided logits to the `Yes` and `No` tokens in the vocabulary and computes their probability."""

    def __init__(self, config: ShieldGemmaConfig):
        self.yes_token_index = getattr(config, "yes_token_index", _DEFAULT_YES_TOKEN_INDEX)
        self.no_token_index = getattr(config, "no_token_index", _DEFAULT_NO_TOKEN_INDEX)

    def __call__(self, logits: torch.Tensor) -> ShieldGemmaClassifierOutput:
        selected_logits = logits[:, -1, [self.yes_token_index, self.no_token_index]]
        probabilities = torch.softmax(selected_logits, dim=-1)
        return ShieldGemmaClassifierOutput(
            logits=selected_logits,
            probabilities=probabilities,
        )


class ShieldGemmaForSequenceClassification(PreTrainedModel):
    config_class = ShieldGemmaConfig

    def __init__(self, config: ShieldGemmaConfig):
        super().__init__(config)
        self.model = AutoModelForCausalLM.from_config(config=config.text_config)
        self.logits_processor = ShieldGemmaLogitsProcessor(config=config)

    def get_input_embeddings(self):
        return self.model.get_input_embeddings()

    def set_input_embeddings(self, value):
        self.model.set_input_embeddings(value)

    def get_output_embeddings(self):
        return self.model.get_output_embeddings()

    def set_output_embeddings(self, new_embeddings):
        self.model.set_output_embeddings(new_embeddings)

    def set_decoder(self, decoder):
        self.model.set_decoder(decoder)

    def get_decoder(self):
        return self.model.get_decoder()

    def tie_weights(self):
        return self.model.tie_weights()

    @deprecate_kwarg("num_logits_to_keep", version="4.50", new_name="logits_to_keep")
    @add_start_docstrings_to_model_forward(SHIELDGEMMA_INPUTS_DOCSTRING)
    @replace_return_docstrings(
        output_type=ShieldGemmaClassifierOutput, config_class=_CONFIG_FOR_DOC
    )
    def forward(self, **kwargs) -> ShieldGemmaClassifierOutput:
        """Predicts the binary probability that the text violates the speicfied policy.

        Args:

        Returns:
        """
        outputs = self.model(**kwargs)
        return self.logits_processor(outputs.logits)


class ShieldGemma2ForImageClassification(PreTrainedModel):
    config_class = ShieldGemmaConfig

    def __init__(self, config: ShieldGemmaConfig):
        super().__init__(config=config)
        self.model = AutoModelForImageTextToText.from_config(config=config)
        self.logits_processor = ShieldGemmaLogitsProcessor(config=config)

    def get_input_embeddings(self):
        return self.model.language_model.get_input_embeddings()

    def set_input_embeddings(self, value):
        self.model.language_model.set_input_embeddings(value)

    def get_output_embeddings(self):
        return self.model.language_model.get_output_embeddings()

    def set_output_embeddings(self, new_embeddings):
        self.model.language_model.set_output_embeddings(new_embeddings)

    def set_decoder(self, decoder):
        self.model.language_model.set_decoder(decoder)

    def get_decoder(self):
        return self.model.language_model.get_decoder()

    def tie_weights(self):
        return self.model.language_model.tie_weights()

    @deprecate_kwarg("num_logits_to_keep", version="4.50", new_name="logits_to_keep")
    @add_start_docstrings_to_model_forward(SHIELDGEMMA_INPUTS_DOCSTRING)
    @replace_return_docstrings(
        output_type=ShieldGemmaClassifierOutput, config_class=_CONFIG_FOR_DOC
    )
    def forward(self, **kwargs) -> ShieldGemmaClassifierOutput:
        """Predicts the binary probability that the image violates the speicfied policy.

        Args:

        Returns:
        """
        outputs = self.model(**kwargs)
        return self.logits_processor(outputs.logits)


__all__ = [
    "ShieldGemmaForSequenceClassification",
    "ShieldGemma2ForImageClassification",
]
